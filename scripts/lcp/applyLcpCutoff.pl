#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2012 Illumina, Inc.

This software is covered by the "Illumina Genome Analyzer Software
License Agreement" and the "Illumina Source Code License Agreement",
and certain third party copyright/licenses, and any user of this
source file is bound by the terms therein (see accompanying files
Illumina_Genome_Analyzer_Software_License_Agreement.pdf and
Illumina_Source_Code_License_Agreement.pdf and third party
copyright/license notices).

This file is part of the BEETL software package.

=head1 NAME

applyLcpCutoff.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX qw(strftime);
use IO::File;
use Carp;

use Pod::Usage;
use Getopt::Long;


my $VERSION = '1.0';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2011 Illumina\n"
  . "This source file is covered by the \"Illumina Public Source License\"\n"
  . "agreement and bound by the terms therein.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-i, --input=PATH             - input file (string of chars)\n"
  . "\t-l, --lcp=PATH               - input LCP file (string of 32-bit integers)\n"
  . "\t-o, --output=PATH            - output file\n"

  . "\t-c, --cutoff=int32           - LCP cutoff threshold\n"
  . "\t-r, --replacement=int8       - char used when LCP is above or equal to the cutoff threshold\n"

  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    $programName \\
      -i BWT/bwt.part1.qual \\
      -l BWT/bwt.part1.lcp \\
      -o newBWT/bwt.part1.qual \\
      -c 10 \\
      -r 255

EXAMPLES_END



my $help = 'nohelp';

my $isVersion = 0;
my %PARAMS = ();

my $argvStr = join ' ', @ARGV;

$PARAMS{verbose} = 0;

$PARAMS{input}  = undef;
$PARAMS{lcp}    = undef;
$PARAMS{bwt}    = undef;
$PARAMS{output} = undef;
my $cutoff      = undef;
my $replacement = undef;


my $result = GetOptions(
    "input|i=s"             => \$PARAMS{input},
    "lcp|l=s"               => \$PARAMS{lcp},
    "bwt|b=s"               => \$PARAMS{bwt},
    "output|o=s"            => \$PARAMS{output},
    "cutoff|c=i"            => \${cutoff},
    "replacement|r=i"       => \${replacement},

    "version"               => \$isVersion,
    "help"                  => \$help
);

# display the version info
if ($isVersion)
{
    print $Version_text;
    exit (0);
}
# display the help text when no output directory or other required options are given
if (($result == 0 || !defined($PARAMS{input}) || !defined($PARAMS{lcp}) || !defined($PARAMS{bwt}) || !defined($PARAMS{output}) || !defined(${cutoff}) || !defined(${replacement}) ) && 'nohelp' eq $help)
{
    die "$usage";
}

die ("ERROR: Unrecognized command-line argument(s): @ARGV") if (0 < @ARGV);


my $myInt8 = "";
my $myInt32 = "";
my $int8Qual = "";
my $int8BwtLetter = "";
open INF_QUAL , "<$PARAMS{input}"  or die "Can't open $PARAMS{input}";
open INF_LCP  , "<$PARAMS{lcp}"    or die "Can't open $PARAMS{lcp}";
open INF_BWT  , "<$PARAMS{bwt}"    or die "Can't open $PARAMS{bwt}";
open OUTF_QUAL, ">$PARAMS{output}" or die "Can't open $PARAMS{output} for writing";
binmode INF_QUAL;
binmode INF_LCP;
binmode INF_BWT;
binmode OUTF_QUAL;

my $packedReplacement = pack('C', $replacement);
my $stretchLength = 0;
my $stretchBwtLetter = "\$";
my $savedQualityStretch = "";
my $brokenStretchCount = 0;
my $successfulStretchCount = 0;
my $cutoffQualitiesCount = 0;
my $lcpValue = 0;
my $lastLcpValueReached = 0;

my $minStretchLength = 5; # should be a command line parameter

read (INF_LCP, $myInt32, 4); # Skip the first LCP value, as it is meaningless


while (1) {

  read (INF_QUAL, $int8Qual, 1) or last;
#  my $qualValue = unpack ('C', $int8Qual);

  if ($cutoff > 0) { # We don't need to read the LCP file if the cutoff threshold is 0
    if (read (INF_LCP, $myInt32, 4)) {
      $lcpValue = unpack ('L', $myInt32);
    } else {
      # We expect to reach the end of the LCP file exactly 1 iteration before the other files, as we skipped the first value
      ($lastLcpValueReached == 0) or die "LCP file should be exactly 4 times as long as the main input file";
      $lastLcpValueReached = 1;
    }
  }

  read (INF_BWT, $int8BwtLetter, 1) or last;
#  my $bwtValue = unpack ('C', $int8BwtLetter);

# lcp_v1: cut off qualities from stretches of lcp>=lcpThreshold with BWT letter constant
# lcp_v2: same as lcp_v1, but also cut off qualities from stretches broken by a change of BWT letter, as long as the stretch length is is longer than minStretchLength
# lcp_v3: lcp_v2 + continue stretches when interrupted by a '$' BWT letter


  if ($lcpValue >= $cutoff) {
    if ($stretchLength == 0) {
      # A new stretch is starting
      $stretchBwtLetter = $int8BwtLetter;
      $stretchLength = 1;
      $savedQualityStretch = $int8Qual;
    } else {
      # Handle the case where a stretch started with BWT letter '$'
      if ($stretchBwtLetter eq '\$') {
        $stretchBwtLetter = $int8BwtLetter;
      }
      if ($int8BwtLetter eq $stretchBwtLetter || $int8BwtLetter eq '\$') {
        # Current stretch is continuing
        $stretchLength++;
      } else {
        # Current stretch broke because BWT letter changed
        if ($stretchLength >= $minStretchLength) {
          for (my $i=0; $i<$stretchLength; $i++) {
            print OUTF_QUAL $packedReplacement;
          }
          $successfulStretchCount++;
          $cutoffQualitiesCount += $stretchLength;
        } else {
          # Print all previous qualities
          print OUTF_QUAL $savedQualityStretch;
          $brokenStretchCount++;
        }
        $stretchBwtLetter = $int8BwtLetter;
        $stretchLength = 1;
        $savedQualityStretch = "";
      }
      $savedQualityStretch .= $int8Qual;
    }
  } else {
    # Current stretch finished because LCP is below threshold
    # We just need to check what the last letter is
    my $lastLetterIsPartOfStretch = 0;
    if ($int8BwtLetter eq $stretchBwtLetter || $int8BwtLetter eq '\$' || $stretchBwtLetter eq '\$') {
      $lastLetterIsPartOfStretch = 1;
      $stretchLength++;
    }
    if ($stretchLength >= $minStretchLength) {
      for (my $i=0; $i<$stretchLength; $i++) {
        print OUTF_QUAL $packedReplacement;
      }
      $successfulStretchCount++;
      $cutoffQualitiesCount += $stretchLength;
      if ($lastLetterIsPartOfStretch == 0) {
        print OUTF_QUAL $int8Qual;
        $brokenStretchCount++;
      }
    }
    else {
      print OUTF_QUAL $savedQualityStretch;
      print OUTF_QUAL $int8Qual;
      $brokenStretchCount++;
    }
    $savedQualityStretch = "";
    $stretchLength = 0;
  }
}


# Final output
if ($stretchLength > 0) {
  my $i;
  for ($i=0; $i<$stretchLength; $i++) {
    print OUTF_QUAL $packedReplacement;
  }
  $successfulStretchCount++;
  $cutoffQualitiesCount += $stretchLength;
}


close INF_QUAL;
close INF_LCP;
close INF_BWT;
close OUTF_QUAL;


print "brokenStretchCount: $brokenStretchCount\n";
print "successfulStretchCount: $successfulStretchCount\n";
print "cutoffQualitiesCount: $cutoffQualitiesCount\n";
